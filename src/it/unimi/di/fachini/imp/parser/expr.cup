package it.unimi.di.fachini.imp.parser;

import it.unimi.di.fachini.imp.compiler.*;
import it.unimi.di.fachini.imp.compiler.ast.*;

import java_cup.runtime.*;

import java.util.List;
import java.util.ArrayList;

class Parser;

// add a reference to the symbol table
action code {:
	protected SymbolTable symbolTable = new SymbolTable();
:}

/**
 * Tokens
 */

// delimiters
terminal COMMA, SEMI_COLON;
// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, UNARY;
// assignments
terminal ASSIGNTO;
// parenthesis
terminal OPEN_PAREN, CLOSE_PAREN;
// reserved keywords
terminal VAR;
// atomitc values
terminal Integer NUM;
terminal String IDENT;

/**
 * AST
 */

non terminal Program prog;
non terminal List<Statement> seqDeclAndStmts;
non terminal Declaration decl;
non terminal List<Descriptor> identSeq;
non terminal Statement stmt;
non terminal Statement assignment;
non terminal Expr expr;

/**
 * Precedence and associativity
 */

precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence nonassoc UNARY;

start with prog;

/* productions */

prog ::= seqDeclAndStmts:s
		 {: RESULT = new Program(s, symbolTable); :}
	   ;

seqDeclAndStmts ::=
		// sequence of variables declaration
		seqDeclAndStmts:seq decl:d
	  	{: seq.add(d); RESULT = seq; :}
	  	// sequence of statements
	  | seqDeclAndStmts:seq stmt:s
		{:  seq.add(s); RESULT = seq; :} 
	  |	// empty
		{: RESULT = new ArrayList<>(); :}
	  ;

decl ::= VAR identSeq:identifiers SEMI_COLON
		 {: RESULT = new Declaration(identifiers); :}
	   ;

identSeq ::= IDENT:id
		   	 {:
				if (symbolTable.contains(id)) {
					throw new CompilerError("Multiple declaration of " + id);
				}
				List<Descriptor> lst = new ArrayList<>();
				Descriptor d = symbolTable.addIdent(id);
				lst.add(d);
				RESULT = lst;
			 :}
		   | identSeq:identifiers COMMA IDENT:id
		   	 {:
				if (symbolTable.contains(id)) {
					throw new CompilerError("Multiple declaration of " + id);
				}
				Descriptor d = symbolTable.addIdent(id);
				identifiers.add(d);
				RESULT = identifiers;
			 :}
		   ;

stmt ::= expr:e SEMI_COLON
	   	 {: RESULT = e; :}
	   | assignment:assignStmt
	   	 {: RESULT = assignStmt; :}
	   | SEMI_COLON
	   	 {: RESULT = AtomFactory.nop(); :}
	   ;

assignment ::= IDENT:ident ASSIGNTO expr:e SEMI_COLON
			   {:
					// throw an exception if an identifier has not been previously declared
			   		if (!symbolTable.contains(ident)) {
			       		throw new CompilerError("Undeclared identifier: " + ident);	
			   		}
			   		Descriptor d = symbolTable.get(ident);
		       		RESULT = StatementFactory.assign(d, e);
		       :}
		 	 ;

expr ::= expr:e1 PLUS expr:e2
	 	 {: RESULT = BinaryOpFactory.add(e1, e2); :}
	   | expr:e1 MINUS expr:e2
	   	 {: RESULT = BinaryOpFactory.sub(e1, e2); :}
	   | expr:e1 MUL expr:e2
	   	 {: RESULT = BinaryOpFactory.mul(e1, e2); :}
	   | expr:e1 DIV expr:e2
	   	 {: RESULT = BinaryOpFactory.div(e1, e2); :}
	   | expr:e1 MOD expr:e2
	   	 {: RESULT = BinaryOpFactory.mod(e1, e2); :}
	   | NUM:n
	   	 {: RESULT = AtomFactory.num(n); :}
	   | IDENT:ident {:
			// throw an exception if an identifier has not been previously declared
			if (!symbolTable.contains(ident)) {
				throw new CompilerError("Undeclared identifier: " + ident);	
			}
			Descriptor d = symbolTable.get(ident);
			RESULT = AtomFactory.var(d);
		 :}
	   | MINUS expr:e
	   	 {: RESULT = UnaryOpFactory.minus(e); :}
	     %prec UNARY
	   | PLUS expr:e
	     {: RESULT = UnaryOpFactory.plus(e); :}
	     %prec UNARY
	   | OPEN_PAREN expr:e CLOSE_PAREN
	     {: RESULT = e; :}
	   ;
