package it.unimi.di.fachini.imp.parser;

import it.unimi.di.fachini.imp.compiler.*;
import it.unimi.di.fachini.imp.compiler.ast.*;
import it.unimi.di.fachini.imp.compiler.ast.atom.AtomFactory;
import it.unimi.di.fachini.imp.compiler.ast.arith.ArithOpFactory;
import it.unimi.di.fachini.imp.compiler.ast.statement.StatementFactory;
import it.unimi.di.fachini.imp.compiler.ast.statement.io.IOStatementFactory;
import it.unimi.di.fachini.imp.compiler.ast.declaration.DeclarationFactory;

import java_cup.runtime.*;

import java.util.List;
import java.util.ArrayList;

class Parser;

action code {:
	// keep a symbol table
	protected SymbolTable symbolTable = new SymbolTable();

	// keep a list for the variables declarations (in the order in which they are defined)
	protected List<Declaration> declarations = new ArrayList<>();
:}

/**
 * Tokens
 */

// delimiters
terminal COMMA, SEMI_COLON;
// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, UNARY;
// assignments
terminal ASSIGNTO;
// parenthesis
terminal OPEN_PAREN, CLOSE_PAREN, OPEN_CURLY_BRACE, ClOSE_CURLY_BRACE;
// reserved keywords
terminal VAR, IF, ELSE, WHILE, WRITE, WRITEMSG, WRITELN;
// atomitc values
terminal Integer NUM;
terminal String IDENT;
terminal String STRING;

/**
 * AST
 */

non terminal Program prog;
non terminal List<Statement> seqDeclAndStmts;
non terminal Declaration decl;
non terminal List<Descriptor> identSeq;
non terminal Statement stmt;
non terminal Statement assignment;
non terminal Statement ifStmt;
non terminal Statement whileStmt;
non terminal Statement writeStmt;
non terminal String string;
non terminal Statement block;
non terminal Expr expr;

/**
 * Precedence and associativity
 */

precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence nonassoc UNARY;

start with prog;

/* productions */

prog ::= seqDeclAndStmts:stmts
		 {: RESULT = new Program("CompiledProg", declarations, stmts, symbolTable); :}
	   ;

seqDeclAndStmts ::= seqDeclAndStmts:stmts decl:d
	  				{:
						declarations.add(d);
						RESULT = stmts;
					:}
	  			  | seqDeclAndStmts:stmts stmt:s
					{:  
						stmts.add(s);
						RESULT = stmts;
					:} 
	 	 		  |	// empty
					{: RESULT = new ArrayList<>(); :}
	  			  ;

decl ::= VAR identSeq:identifiers SEMI_COLON
		 {: RESULT = DeclarationFactory.var(identifiers); :}
	   ;

identSeq ::= IDENT:id
		   	 {:
				if (symbolTable.contains(id)) {
					throw new CompilerError("Multiple declaration of " + id);
				}
				List<Descriptor> lst = new ArrayList<>();
				Descriptor d = symbolTable.addIdent(id);
				lst.add(d);
				RESULT = lst;
			 :}
		   | identSeq:identifiers COMMA IDENT:id
		   	 {:
				if (symbolTable.contains(id)) {
					throw new CompilerError("Multiple declaration of " + id);
				}
				Descriptor d = symbolTable.addIdent(id);
				identifiers.add(d);
				RESULT = identifiers;
			 :}
		   ;

stmt ::= assignment:assignStmt
	   	 {: RESULT = assignStmt; :}
	   | ifStmt:ifStatement
	   	 {: RESULT = ifStatement; :}
	   | whileStmt:whileStatement
	   	 {: RESULT = whileStatement; :}
	   | writeStmt:wstmt
	   	 {: RESULT = wstmt; :}
	   | block:blockStatement
	   	 {: RESULT = blockStatement; :}
	   | SEMI_COLON
	   	 {: RESULT = StatementFactory.nop(); :}
	   ;

assignment ::= IDENT:ident ASSIGNTO expr:e SEMI_COLON
			   {:
					// throw an exception if an identifier has not been previously declared
			   		if (!symbolTable.contains(ident)) {
			       		throw new CompilerError("Undeclared identifier: " + ident);	
			   		}
			   		Descriptor d = symbolTable.get(ident);
		       		RESULT = StatementFactory.assign(d, e);
		       :}
		 	 ;

ifStmt ::= IF OPEN_PAREN expr:condition CLOSE_PAREN stmt:consequent
		   {: RESULT = StatementFactory.ifStmt(condition, consequent); :}
		 | IF OPEN_PAREN expr:condition CLOSE_PAREN stmt:consequent ELSE stmt:alternative
		   {: RESULT = StatementFactory.ifStmt(condition, consequent, alternative); :}
		 ;

whileStmt ::= WHILE OPEN_PAREN expr:condition CLOSE_PAREN stmt:body
			  {: RESULT = StatementFactory.whileStmt(condition, body); :}
			; 

writeStmt ::= WRITE expr:e SEMI_COLON
			  {: RESULT = IOStatementFactory.write(e); :}
			| WRITEMSG string:s
			  {: RESULT = IOStatementFactory.writeMessage(s); :}
			| WRITELN SEMI_COLON
			  {: RESULT = IOStatementFactory.writeMessage("\n"); :}
			;

string ::= STRING:s {: RESULT = s; :};

block ::= OPEN_CURLY_BRACE seqDeclAndStmts:statements ClOSE_CURLY_BRACE
		  {: RESULT = StatementFactory.block(statements); :}
		;

expr ::= NUM:n
	   	 {: RESULT = AtomFactory.num(n); :}
	   | IDENT:ident {:
			// throw an exception if an identifier has not been previously declared
			if (!symbolTable.contains(ident)) {
				throw new CompilerError("Undeclared identifier: " + ident);	
			}
			Descriptor d = symbolTable.get(ident);
			RESULT = AtomFactory.var(d);
		 :}
	   | expr:e1 PLUS expr:e2
	 	 {: RESULT = ArithOpFactory.add(e1, e2); :}
	   | expr:e1 MINUS expr:e2
	   	 {: RESULT = ArithOpFactory.sub(e1, e2); :}
	   | expr:e1 MUL expr:e2
	   	 {: RESULT = ArithOpFactory.mul(e1, e2); :}
	   | expr:e1 DIV expr:e2
	   	 {: RESULT = ArithOpFactory.div(e1, e2); :}
	   | expr:e1 MOD expr:e2
	   	 {: RESULT = ArithOpFactory.mod(e1, e2); :}
	   | MINUS expr:e
	   	 {: RESULT = ArithOpFactory.unaryMinus(e); :}
	     %prec UNARY
	   | PLUS expr:e
	     {: RESULT = ArithOpFactory.unaryPlus(e); :}
	     %prec UNARY
	   | OPEN_PAREN expr:e CLOSE_PAREN
	     {: RESULT = e; :}
	   ;
