package it.unimi.di.fachini.imp.compiler;

import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;
import static org.objectweb.asm.ClassWriter.COMPUTE_MAXS;
import static org.objectweb.asm.Opcodes.*;
import it.unimi.di.fachini.imp.compiler.ast.ASTVisitor;
import it.unimi.di.fachini.imp.compiler.ast.Statement;
import it.unimi.di.fachini.imp.compiler.ast.arith.AddExpr;
import it.unimi.di.fachini.imp.compiler.ast.arith.DivExpr;
import it.unimi.di.fachini.imp.compiler.ast.arith.ModExpr;
import it.unimi.di.fachini.imp.compiler.ast.arith.MulExpr;
import it.unimi.di.fachini.imp.compiler.ast.arith.SubExpr;
import it.unimi.di.fachini.imp.compiler.ast.arith.UnaryMinusExpr;
import it.unimi.di.fachini.imp.compiler.ast.atom.NumExpr;
import it.unimi.di.fachini.imp.compiler.ast.atom.VarExpr;
import it.unimi.di.fachini.imp.compiler.ast.conditional.Condition;
import it.unimi.di.fachini.imp.compiler.ast.conditional.ConditionType;
import it.unimi.di.fachini.imp.compiler.ast.statement.AssignStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.BlockStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.DoWhileStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.EmptyStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.ForStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.IfStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.WhileStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.io.ReadStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.io.WriteMessageStatement;
import it.unimi.di.fachini.imp.compiler.ast.statement.io.WriteStatement;
import it.unimi.di.fachini.imp.compiler.declaration.Declaration;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

public class CodeGenerator implements ASTVisitor {
	private MethodVisitor mv;
	private int nextLocalVar;
	private int scannerIndex;
	private int inputIndex, outputIndex;
	private final String programName;

	public CodeGenerator(String programName) {
		this.programName = programName;
	}
	
	private void resetLocalVariables() {
		nextLocalVar = 0;
		scannerIndex = 0;
		inputIndex = 0;
		outputIndex = 0;
	}

	private int reserveLocal() {
		return nextLocalVar++;
	}

	private int destroyLocal() {
		return --nextLocalVar;
	}
	
	public byte[] compile(Program program) {
		resetLocalVariables();

		// creates a ClassWriter to compile the parsed program
		ClassWriter cw = new ClassWriter(COMPUTE_FRAMES | COMPUTE_MAXS);
		cw.visit(V1_8, ACC_PUBLIC, programName, null, "java/lang/Object", null);

		/*
		 * Generate the bytecode for the default constructor, the program code
		 * and the main function.
		 */
		genDefaultConstructor(program, cw);
		genExecute(program, cw);
		genMain(program, cw);

		// return the generated bytecode
		return cw.toByteArray();
	}

	private void genMain(Program program, ClassWriter cw) {
		mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
		mv.visitCode();

		// execute the program by calling execute(System.in, System.out)
		mv.visitFieldInsn(GETSTATIC, "java/lang/System", "in", "Ljava/io/InputStream;");
		mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
		mv.visitMethodInsn(INVOKESTATIC, programName, "execute", "(Ljava/io/InputStream;Ljava/io/PrintStream;)V", false);

		// exit from the main method
		mv.visitInsn(RETURN);
		mv.visitMaxs(-1,-1);
		mv.visitEnd();
	}

	private void genExecute(Program program, ClassWriter cw) {
		// public static void execute(InputStream in, PrintStream out)
		mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,
							"execute", "(Ljava/io/InputStream;Ljava/io/PrintStream;)V",
							null, null);
		mv.visitCode();

		// reserve a local variable for each argument
		inputIndex = reserveLocal();  // InputStream in
		outputIndex = reserveLocal(); // PrintStream out

		// create a new java.util.Scanner object
		mv.visitTypeInsn(NEW, "java/util/Scanner");
		mv.visitInsn(DUP);
		// retrieve the input stream from the local variables
		mv.visitVarInsn(ALOAD, inputIndex);
		mv.visitMethodInsn(INVOKESPECIAL, "java/util/Scanner", "<init>", "(Ljava/io/InputStream;)V", false);
		// store the created object as a local variable
		scannerIndex = reserveLocal();
		mv.visitVarInsn(ASTORE, scannerIndex);

		// declare local variables
		for (Declaration decl : program.getDeclarations()) {
			for (Descriptor descriptor : decl.getDeclaredIdentifiers()) {
				descriptor.setIndex(reserveLocal());
			}
		}

		// compile the program statement by statement
		for (Statement stmt : program.getStatements()) {
			stmt.accept(this);
		}

		// return from the method
		mv.visitInsn(RETURN);
		mv.visitMaxs(-1, -1);
		mv.visitEnd();
	}

	private void genDefaultConstructor(Program program, ClassWriter cw) {
		mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
		mv.visitCode();
		// pushes the 'this' variable
		mv.visitVarInsn(ALOAD, 0);
		// invokes the super class constructor
		mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
		mv.visitInsn(RETURN);
		// this code uses a maximum of one stack element and one local variable
		mv.visitMaxs(-1, -1);
		mv.visitEnd();
	}

	@Override
	public void visitNum(NumExpr expr) {
		mv.visitLdcInsn(expr.getValue());
	}

	@Override
	public void visitVar(VarExpr expr) {
		mv.visitVarInsn(ILOAD, expr.getDescriptor().getIndex());
	}

	@Override
	public void visitAdd(AddExpr expr) {
		expr.getLeft().accept(this);
		expr.getRight().accept(this);
		mv.visitInsn(IADD);
	}

	@Override
	public void visitSub(SubExpr expr) {
		expr.getLeft().accept(this);
		expr.getRight().accept(this);
		mv.visitInsn(ISUB);
	}

	@Override
	public void visitMul(MulExpr expr) {
		expr.getLeft().accept(this);
		expr.getRight().accept(this);
		mv.visitInsn(IMUL);
	}

	@Override
	public void visitDiv(DivExpr expr) {
		expr.getLeft().accept(this);
		expr.getRight().accept(this);
		mv.visitInsn(IDIV);
	}

	@Override
	public void visitMod(ModExpr expr) {
		// reserve two local variables for keeping left and right
		int a = reserveLocal();
		int b = reserveLocal();

		// compile left and right, thus put the result in 'a' and 'b'
		expr.getLeft().accept(this);
		mv.visitVarInsn(ISTORE, a);
		expr.getRight().accept(this);
		mv.visitVarInsn(ISTORE, b);

		// the MOD operation can be computed as: a % b = a - b*(a/b)
		// in postfix it becomes a b a b / * -
		mv.visitVarInsn(ILOAD, a);
		mv.visitVarInsn(ILOAD, b);
		mv.visitVarInsn(ILOAD, a);
		mv.visitVarInsn(ILOAD, b);
		mv.visitInsn(IDIV);
		mv.visitInsn(IMUL);
		mv.visitInsn(ISUB);

		// destroy the temporary local variables
		destroyLocal();
		destroyLocal();
	}

	@Override
	public void visitUnaryMinus(UnaryMinusExpr expr) {
		expr.getTarget().accept(this);
		mv.visitInsn(INEG);
	}

	@Override
	public void visitWrite(WriteStatement writeStmt) {
		// retrieve the output stream from the local variables
		mv.visitVarInsn(ALOAD, outputIndex);

		// compile the expression to be printed and push it onto the stack
		writeStmt.getExpr().accept(this);

		// invoke Integer.toString(expr)
		mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "toString",
				"(I)Ljava/lang/String;", false);

		// invoke System.out.println()
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "print",
				"(Ljava/lang/String;)V", false);
	}

	@Override
	public void visitWriteMessage(WriteMessageStatement writeMsgStmt) {
		// retrieve the output stream from the local variables
		mv.visitVarInsn(ALOAD, outputIndex);

		// push the string to be printed
		mv.visitLdcInsn(writeMsgStmt.getMessage());

		// invoke the 'print' method (defined in the PrintStream class)
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "print", "(Ljava/lang/String;)V", false);
	}

	@Override
	public void visitRead(ReadStatement readStmt) {
		// push onto the stack the Scanner object stored as local variable
		mv.visitVarInsn(ALOAD, scannerIndex);
		// call nextInt() on the created object
		mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/Scanner", "nextInt", "()I", false);
		// put the read value in the specified variable
		mv.visitVarInsn(ISTORE, readStmt.getDestination().getIndex());
	}

	@Override
	public void visitAssign(AssignStatement assign) {
		assign.getValue().accept(this);
		mv.visitVarInsn(ISTORE, assign.getTarget().getIndex());
	}

	@Override
	public void visitBlock(BlockStatement block) {
		// compile the statements sequentially
		for (Statement stmt : block.getStatements()) {
			stmt.accept(this);
		}
	}

	@Override
	public void visitEmpty(EmptyStatement empty) {
		mv.visitInsn(NOP);
	}

	@Override
	public void visitIf(IfStatement ifStmt) {
		// push (cond.left - cond.right) onto the stack
		Condition cond = ifStmt.getCondition();
		cond.getLeft().accept(this);
		cond.getRight().accept(this);
		mv.visitInsn(ISUB);

		// evaluate the result accordingly to the condition type
		Label alternativeOrEnd = new Label();
		mv.visitJumpInsn(getConditionOpcode(cond.getType()), alternativeOrEnd);

		// consequent branch
		ifStmt.getConsequent().accept(this);
		Label end = new Label();
		mv.visitJumpInsn(GOTO, end);

		// alternative branch (if it exists)
		mv.visitLabel(alternativeOrEnd);
		if (ifStmt.hasAlternative()) {
			ifStmt.getAlternative().accept(this);
		}

		// if's end
		mv.visitLabel(end);
	}

	@Override
	public void visitWhile(WhileStatement whileStmt) {
		// loop's start
		Label loop = new Label();
		mv.visitLabel(loop);

		// compute (cond.left - cond.right) onto the stack
		Condition cond = whileStmt.getCondition();
		cond.getLeft().accept(this);
		cond.getRight().accept(this);
		mv.visitInsn(ISUB);

		// evaluate the result accordingly to the condition type
		Label end = new Label();
		mv.visitJumpInsn(getConditionOpcode(cond.getType()), end);

		// body
		whileStmt.getBody().accept(this);
		mv.visitJumpInsn(GOTO, loop);

		// loop's end
		mv.visitLabel(end);
	}

	@Override
	public void visitDoWhile(DoWhileStatement doWhileStmt) {
		// loop's start
		Label loop = new Label();
		mv.visitLabel(loop);

		// body
		doWhileStmt.getBody().accept(this);

		// compute (cond.left - cond.right) onto the stack
		Condition cond = doWhileStmt.getCondition();
		cond.getLeft().accept(this);
		cond.getRight().accept(this);
		mv.visitInsn(ISUB);

		// evaluate the result accordingly to the condition type
		Label end = new Label();
		mv.visitJumpInsn(getConditionOpcode(cond.getType()), end);
		mv.visitJumpInsn(GOTO, loop);

		// loop's end
		mv.visitLabel(end);
	}

	public void visitFor(ForStatement forStmt) {
		// create the labels for compiling the loop
		Label loop = new Label();
		Label checkLower = new Label();
		Label body = new Label();
		Label end = new Label();

		// initialize the iteration variable
		int iterIndex = forStmt.getIterVar().getIndex();
		forStmt.getStart().accept(this);
		mv.visitVarInsn(ISTORE, iterIndex);

		// reserve a local variable for the end value
		int endIndex = reserveLocal();
		forStmt.getEnd().accept(this);
		mv.visitVarInsn(ISTORE, endIndex);

		// reserve a local variable for the step value
		int stepIndex = reserveLocal();
		forStmt.getStep().accept(this);
		mv.visitVarInsn(ISTORE, stepIndex);

		// loop's start and end
		mv.visitLabel(loop);

		// check the condition accordingly to the step value (positive/negative)
		mv.visitVarInsn(ILOAD, stepIndex);
		mv.visitJumpInsn(IFLT, checkLower);

		// exit if the iteration variable is greater than end
		mv.visitVarInsn(ILOAD, iterIndex);
		mv.visitVarInsn(ILOAD, endIndex);
		mv.visitInsn(ISUB);
		mv.visitJumpInsn(IFGT, end);
		mv.visitJumpInsn(GOTO, body);

		// exit if the iteration variable is lower than end
		mv.visitLabel(checkLower);
		mv.visitVarInsn(ILOAD, iterIndex);
		mv.visitVarInsn(ILOAD, endIndex);
		mv.visitInsn(ISUB);
		mv.visitJumpInsn(IFLT, end);

		// loop's body
		mv.visitLabel(body);
		forStmt.getBody().accept(this);

		// step increment/decrement
		mv.visitVarInsn(ILOAD, iterIndex);
		mv.visitVarInsn(ILOAD, stepIndex);
		mv.visitInsn(IADD);
		mv.visitVarInsn(ISTORE, iterIndex);

		// jump to the start
		mv.visitJumpInsn(GOTO, loop);

		// loop's end
		mv.visitLabel(end);

		// destroy the local variable used for the step and the end variable
		destroyLocal();
		destroyLocal();
	}

	private int getConditionOpcode(ConditionType type) {
		switch (type) {
			case EQ: return IFNE;
			case NE: return IFEQ;
			case GE: return IFLT;
			case GT: return IFLE;
			case LE: return IFGT;
			case LT: return IFGE;
			default: throw new IllegalStateException("Invalid condition given: " + type);
		}
	}
}
